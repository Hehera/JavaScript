https://learn.javascript.ru/dom-nodes#primer-dom
Зміст 
Браузерне оточення, специфікації
DOM-дерево
Навігація по DOM
Пошук: getElement, querySelector
--------------------------------------------
Браузерне оточення, специфікації =>> УРОК 1
--------------------------------------------
Мова програмування JavaScript спочатку була створена для веббраузерів. Платформою може бути браузер, або вебсервер(Node.js забезпечує функції сервера) або інший хост.Тобто платформа,це функціональність тоді це - середовище.Середовище надає власні об’єкти та додаткові функції до базової мови.

                        що ми маємо, коли JS працює в веббраузері
                                            window 
     1.document(DOM)   2.BOM(navigator,screen,location,frames,history,XMLHttpRequests) 3.JS(Object,Array,Function)

Існує “корінний” об’єкт, що називається window. Він має дві ролі:
По-перше, це глобальний об’єкт.
По-друге, він являє собою “вікно браузера” та надає способи для керування ним.

До всіх властивостей глобального об’єкта можна отримати доступ напряму:
Приклад 1
function sayHi() {
alert("Привіт");
}
// глобальні функції є методами глобального об’єкта:
window.sayHi();
приклад 2 alert(window.innerHeight); // внутрішня висота вікна
--------------------------
Document Object Model =>>
--------------------------
Document Object Model – представляє весь контент сторінки як об’єкти, які можуть бути змінені.
об’єкт document – це головна “точка входу” до сторінки. Ми можемо взаємодіяти з сторінкою використовуючи цей об’єкт.

Приклад 1
// змінити колір фону на червоний
document.body.style.background = "red";

// повернути його назад після 1 секунди
setTimeout(() => document.body.style.background = "", 1000);

(i) - DOM – не лише для браузерів існують також,інші інструменти окрім браузерів, які також використовують DOM.
Наприклад, скрипти сервера, які завантажують HTML-сторінки та обробляють їх також можуть використовувати DOM.
-------------------------------
BOM (Browser Object Model) =>>
-------------------------------
Browser Object Model – це додаткові об’єкти, надані браузером (хост-середовищем) для роботи з усім, крім документа.

Наприклад:

- Об’єкт navigator забезпечує інформацію про браузер та операційну систему:
navigator.userAgent – інформація про поточний браузер
navigator.platform – про платформу  (Win32)
- Об’єкт location  URL-адреса і може перенаправити веббраузер на нову адресу.

Ось як ми можемо використовувати об’єкт location:
alert(location.href); // показує поточний URL-адрес
if (confirm("Перейти на сайт Wikipedia?")) {
  location.href = "https://wikipedia.org"; // перенаправляє браузер на іншу URL-адресу
}
Функції alert/confirm/prompt також є частиною BOM: вони безпосередньо не пов’язані з документом, але являють собою чисті методи взаємодії з користувачем.
---------
Підсумки
---------
Історично склалось,що JS був створений для веббраузерів.Але зараз може використовуватись на платформах  браузер, або вебсервер(Node.js забезпечує функції сервера) або інший хост.
Тобто платформа,це функціональність тоді це - середовище.Середовище надає власні об’єкти та додаткові функції до базової мови.

Коли ми працюємо в браузері ми працюємо з : window => DOM,BOM,JS

Document Object Model – представляє HTML-документ у вигляді дерева об'єктів, де кожен тег є вузлом-елементом, текст всередині тега є текстовим вузлом.
.document – це об’єкт головна “точка входу” до сторінки. Ми можемо взаємодіяти з сторінкою використовуючи цей об’єкт.

Browser Object Model – це додаткові об’єкти, надані браузером (хост-середовищем) для роботи з усім, крім документа.(наприклад navigator.userAgent,navigator.platform,location,також функції alert,confirm,prompt)
--------------------
DOM-дерево =>>УРОК 2
--------------------
Текст всередині тега також є об'єктом.Наприклад, document.body - це об'єкт для тега <body>.

Приклад дерева
<!DOCTYPE HTML>
<html>
<head>
  <title>О лосях</title>
</head>
<body>
  Правда о лосях.
</body>
</html>


Коли ми в консолі нажимаємо на теги html,head,body - це є вузли-елементи і їх діти будуть скриватися і розкриватися.

1.Текст усередині елементів утворює текстові вузли, що позначені як #text.
Наприклад, у тезі <title> є текстовий вузол "Про лося".
Пробіли і перенос вони теж формують текстовий вузол.

--------------------
Автовиправлення =>>
--------------------
Якщо браузер стикається з некоректно написаним HTML-кодом, він автоматично коригує його під час побудови DOM(добавляє щось,якщо було щось пропущено,синтаксис поправляє).
Якщо в html одне слово Привіт,то він сам добавить html - head - body -- #text

!!Таблиці завжди містять <tbody>

<table id="table"><tr><td>1</td></tr></table> => <tbody> - браузер сам добавляє

--------------------
Інші типи вузлів =>>
--------------------
Все, що є в HTML, навіть коментарі є частиною DOM.
Є й інші типи вузлів, крім елементів і текстових вузлів це коментар(#comment)
Навіть директива <!DOCTYPE...>, яку ми ставимо на початку HTML, також є DOM-вузлом.
Навіть об'єкт document, який представляє весь документ, формально є DOM-вузлом.

Існує 12 типів вузлів. Але на практиці ми в основному працюємо з 4 з них:

/документ\ – «вхідна точка» в DOM.
/вузли-елементи\ – HTML-теги, основні будівельні блоки.
/текстові вузли\ – містять текст.
/коментарі\ – іноді в них можна включити інформацію, яка не буде показана, але доступна в DOM для читання JS.

--------------------------
Експерементування DOM =>>
--------------------------
У правій частині інструментів розробника знаходяться такі підрозділи:
1.Styles – тут ми бачимо CSS, застосований до поточного елементу
2.Computed  - візуально бачим результат задання стилів
3.Event Listeners – у цьому розділі ми бачимо обробники подій, прив'язані до DOM-елементів

document.body - побачити розмітку body

-------------
Висновок =>>
-------------
Document Object Model - представляє HTML-документ у вигляді дерева об'єктів, де кожен тег є вузлом-елементом, текст всередині тега є текстовим вузлом.

HTML/XML документи представлені у браузері як DOM-дерева.

Для зміни елементів або перевірки DOM-дерева ми можемо використовувати інструменти розробника у браузері.
У DOM-вузлів є властивості та методи, які дозволяють взаємодіяти з елементом на сторінці.

---------------------------
Навігація по DOM =>> УРОК 3
---------------------------
Усі операції з DOM починаються з об’єкта document. Це головна “точка входу” в DOM. З нього ми можемо отримати доступ до будь-якого вузла.
Ось так виглядають основні посилання, які дозволяють переміщатися між вузлами DOM:
--------
document
--------
|
-------------------------------
document.documentElement <HTML>
-------------------------------
|
-------------------------------
document.body (Якщо у body)
-------------------------------
|
parentNode
------
<div>  childNodes => previousSibling,nextSibling,firstChild,lastChild
------

Обговоримо їх більш детально.
Найвищі вузли дерева доступні безпосередньо як властивості document:
1.<html> = document.documentElement - найвищий вузол документа 
2.Іншим широко використовуваним вузлом DOM є елемент <body> – document.body.
Тег <head> доступний як document.head.

(i) - Але є заковика: document.body може бути null. (i) -  У світі DOM null означає “не існує”

Скрипт не може отримати доступ до елемента, який не існує на момент виконання цього скрипта.
Зокрема, якщо скрипт знаходиться всередині <head>, то document.body недоступний, оскільки браузер ще не прочитав його.

------------------------------------------------
Дочірні вузли: childNodes, firstChild, lastChild
------------------------------------------------
Дочірні вузли (або діти) – елементи, які є безпосередніми дітьми. Іншими словами, вони вкладені саме в цей вузол. Наприклад, <head> і <body> є дочірніми елементами <html>.   
Нащадки – всі елементи, які вкладені в даний, включаючи дітей, їхніх дітей тощо.

Наприклад, якщо у нас є структура HTML, де <body> має дочірні елементи <div> і <ul>, а <div> також має дочірній елемент <p>, то всі ці елементи <div>, <ul> і <p> є нащадками <body>.


Колекція childNodes містить список усіх дочірніх вузлів, включаючи текстові вузли.

 <script>
    for (let i = 0; i < document.body.childNodes.length; i++) {
      console.log(document.body.childNodes[i]); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>

Властивості firstChild і lastChild надають швидкий доступ до першого та останнього дочірнього вузла.
Це лише скорочення. Якщо існують дочірні вузли, то завжди вірно наступне:

elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild

Існує також спеціальна функція elem.hasChildNodes(), що перевіряє, чи є взагалі дочірні вузли.
------------
DOM колекції
------------
Як бачимо, childNodes виглядає як масив. Але насправді це не масив, а скоріше колекція – спеціальний ітеративний об’єкт-псевдомасив.
Є два важливих наслідки з цього:
Ми можемо використовувати for..of, щоб перебирати його:
for (let node of document.body.childNodes) {
  alert(node); // показує всі вузли з колекції
}
Це працює, бо колекція є ітерованим об’єктом (є потрібний для цього метод Symbol.iterator).
Методи масиву не працюватимуть, бо колекція це не масив:
alert(document.body.childNodes.filter); // undefined (методу filter немає!)

Ми можемо використовувати Array.from для створення “справжнього” масиву з колекції, якщо нам потрібні методи масиву:
alert( Array.from(document.body.childNodes).filter ); // function

(i) - Колекції DOM доступні лише для зчитування
    Колекції DOM і навіть більше – всі властивості навігації, перелічені в цьому розділі, доступні лише для зчитування.
    Ми не можемо замінити дочірній елемент на щось інше, призначивши childNodes[i] = ....
    Для зміни DOM потрібні інші методи.
(i) - DOM колецкції живі
Майже всі колекції DOM, за незначними винятками, є живими. Іншими словами, вони завжди відображають поточний стан DOM.

(i) - не використовуйте for..in для перебору колекцій, for of
Цикл for..in перебирає всі властивості без виключення. А колекції мають деякі “додаткові” рідко використовувані властивості, які ми зазвичай не хочемо отримувати
----------------------------
Сусіди та батьківський вузол
----------------------------
Сусіди, або сусідні вузли – це вузли, які є нащадками одного батька.

Наступний сусід знаходиться у властивості nextSibling, а попередній – у previousSibling.

Батьківський вузол доступний як parentNode.

Приклади:
// батьком <body> є <html>
alert( document.body.parentNode === document.documentElement ); // true

// після <head> іде <body>
alert( document.head.nextSibling ); // HTMLBodyElement

// після <body> іде <head>
alert( document.body.previousSibling ); // HTMLHeadElement

----------------------------
Навігація лише за елементами
----------------------------
Властивості навігації, перераховані вище, відносяться до всіх вузлів в документі. Наприклад, у childNodes ми можемо побачити як текстові вузли, так і вузли елементів і навіть вузли коментарів, якщо вони існують.

Але для багатьох задач нам не потрібні текстові вузли чи вузли коментарів. Ми хочемо маніпулювати вузлами елементів, які представляють теги та формують структуру сторінки.

Тож давайте розглянемо додатковий набір посилань, які враховують лише вузли-елементи:

------------------------------
document.documentElement (html)
------------------------------
|
-----------------------------
document.body (якщо в body)
-----------------------------
|
parentElement
-------------
<DIV> - previousElementSibling,nextElementSibling,children,firstElementChild,lastElementChild
-------------

Посилання подібні до наведених вище, лише із словом Element всередині:
children – колекція дітей, які є елементами.
firstElementChild, lastElementChild – перший і останній дочірні елементи.
previousElementSibling, nextElementSibling – сусідні елементи.
parentElement – батьківський елемент.

Чому parentElement? Чи може батько бути не елементом?
Властивість parentElement повертає батьківський елемент “element”, тоді як parentNode повертає батьківський “будь-який вузол”.
За винятком document.documentElement:
alert( document.documentElement.parentNode ); // document
alert( document.documentElement.parentElement ); // null

Тепер childNodes на children. Тепер він показує лише елементи:
for (let elem of document.body.children) {
    alert(elem); // DIV, UL, DIV, SCRIPT
}
--------
Підсумки
--------
Дочірні вузли - це елементи, які є безпосередніми дітьми певного вузла. Наприклад, в контексті HTML <body> може мати дочірні елементи <div>, <ul>,
Нащадки - це всі елементи, які вкладені в даний вузол, включаючи дітей, їхніх дітей і так далі. 

Колекція childNodes 
childNodes  – це спеціальний ітеративний об’єкт-псевдомасив,містить список усіх дочірніх вузлів, включаючи текстові вузли.
(i) - Колекції DOM доступні лише для зчитування

Сусіди - це вузли, які є нащадками одного батька.
Батьківський вузол доступний як parentNode.
-----------------------------
Навігація лише за елементами
-----------------------------
children – колекція дітей, які є елементами.
firstElementChild, lastElementChild – перший і останній дочірні елементи.
previousElementSibling, nextElementSibling – сусідні елементи.
parentElement – батьківський елемент.

Чому parentElement? Чи може батько бути не елементом?
Властивість parentElement має батька,вузол parentNode може не мати.

Для вузла DOM та для навігації елементів, ми можемо перейти до його безпосередніх сусідів за допомогою властивостей навігації.

Існує два основних набори:

Для всіх вузлів: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
Для елементів: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.

Чи правда що elem.lastChild.nextSibling завжди null?
Так, це правда. Елемент elem.lastChild завжди останній, у нього немає nextSibling.

Чи правда що elem.children[0].previousSibling завжди null?
Ні, це неправда, тому що elem.children[0] — перший дочірній серед елементів. Але перед ним можуть існувати вузли інших типів. Отже, previousSibling може бути, наприклад, текстовим вузлом.
--------
Завдання
--------

Якщо elem – це довільний DOM елемент…

Чи правда що elem.lastChild.nextSibling завжди null?
Так, це правда. Елемент elem.lastChild завжди останній, у нього немає nextSibling.
Чи правда що elem.children[0].previousSibling завжди null?
Ні, це неправда, тому що elem.children[0] — перший дочірній серед елементів. Але перед ним можуть існувати вузли інших типів. Отже, previousSibling може бути, наприклад, текстовим вузлом.

Зверніть увагу: в обох випадках якщо немає дітей, то буде помилка.
--------------------------------------------
Пошук: getElement, querySelector =>> УРОК 4
--------------------------------------------
Властивості навігації по DOM чудові, коли елементи розташовані близько один до одного. А якщо ні? Як отримати довільний елемент сторінки?

document.getElementById(id) - <div id="elem-content">Елемент</div>//містить дефіс(не можна) =>  але так можна window['elem-content']
elem.querySelectorAll(css), який повертає всі елементи всередині elem(має статичну колекцію,як фіксований масив,а старі методи пошуки видають живу колекцію)
document.querySelectorAll('#age-table label') клас #age-table > label

elem.querySelector(css) повертає перший елемент, що відповідає даному CSS-селектору
document.querySelector('#age-table td') document.querySelector('form[name="search"]')

elem.matches(css) нічого не шукає, він просто перевіряє, чи відповідає elem заданому CSS-селектору. Він повертає true або false.
closest шукає предка і повертається знайдений предок.

4.1 matches

    <div class="content__table">
    <ul class="star-list">
        <li class="star">Про сіріус</li>
        <li class="star">Про альдебаран</li>
        <li class="contact">Зворотній зв'язок</li>
    </ul>
    </div>

    let list = document.querySelectorAll('ul.star-list > li')
    for (item of list) {
        Якщо li з класом star співпадає - виводить цю розмітку
        if (item.matches('li.star')) console.log(item.outerHTML)
    }


4.2 closest

<h1>Зміст</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">Розділ 1</li>
    <li class="chapter">Розділ 2</li>
  </ul>
</div>


4.3 contains - Якщо elemA містить elemB повертає boolean
    <div id="parent-element">
    <p id="my-element">Це є нащадок</p>
    </div>
    const element = document.getElementById("my-element");
    const parent = document.getElementById("parent-element");
    console.log(parent.contains(element)); // true


--------------------------------------------
Пошук: getElement, querySelector Підсумки
--------------------------------------------

1.document.getElementById(id) - <div id="elem-content">Елемент</div>//містить дефіс(не можна) =>  але так можна window['elem-content']
2.elem.querySelectorAll(css), який повертає всі елементи всередині elem(має статичну колекцію,як фіксований масив,а старі методи пошуки видають живу колекцію)
document.querySelectorAll('#age-table label') клас #age-table > label
4.elem.querySelector(css) повертає перший елемент, що відповідає даному CSS-селектору
document.querySelector('#age-table td') document.querySelector('form[name="search"]')

6.elem.matches(css) нічого не шукає, він просто перевіряє, чи відповідає elem заданому CSS-селектору. Він повертає true або false.
7.closest шукає предка і повертається знайдений предок.

