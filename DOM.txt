https://learn.javascript.ru/dom-nodes#primer-dom
Зміст 
Браузерне оточення, специфікації
DOM-дерево
Навігація по DOM
Пошук: getElement, querySelector

--------------------------------------------
Браузерне оточення, специфікації =>> УРОК 1
--------------------------------------------
    Мова програмування JavaScript спочатку була створена для веббраузерів. Платформою може бути браузер, або вебсервер(Node.js забезпечує функції сервера) або інший хост.Тобто платформа,це функціональність тоді це - середовище.Середовище надає власні об’єкти та додаткові функції до базової мови.
    

                        що ми маємо, коли JS працює в веббраузері
                                            window 
     1.document(DOM)   2.BOM(navigator,screen,location,frames,history,XMLHttpRequests) 3.JS(Object,Array,Function)

Існує “корінний” об’єкт, що називається window. Він має дві ролі:
По-перше, це глобальний об’єкт,який містить змінні, які мають бути доступними скрізь.
По-друге, він являє собою “вікно браузера” та надає способи для керування ним.
--------------------------
Document Object Model =>>
--------------------------
Document Object Model – HTML документ представляє весь контент сторінки у вигляді дерева як об’єкти, де кожен тег являється вузлом-елементом,ці елементи створюють ієрархічну структуру, де кожен елемент може мати батьківський, дочірній та сусідні елементи.

об’єкт document – це головна “точка входу” до сторінки. Ми можемо взаємодіяти з сторінкою використовуючи цей об’єкт.

(i) - DOM – не лише для браузерів існують також,але й наприклад для скриптів  сервера, які завантажують HTML-сторінку.
-------------------------------
BOM (Browser Object Model) =>>
-------------------------------
Browser Object Model – це додаткові об’єкти, надані браузером (хост-середовищем) для роботи з усім, крім документа.(наприклад navigator.userAgent,navigator.platform,location,також функції alert,confirm,prompt)
--------------------
DOM-дерево =>>УРОК 2
--------------------
document.body - це об'єкт для тега <body>.
html,head,body - це є вузли-елементи.
--------------------
Автовиправлення =>>
--------------------
Якщо браузер стикається з некоректно написаним HTML-кодом, він автоматично коригує його під час побудови DOM.
!!Таблиці завжди містять <tbody>
<table id="table"><tr><td>1</td></tr></table> => <tbody> - браузер сам добавляє
--------------------
Інші типи вузлів =>>
--------------------
Є й інші типи вузлів, крім елементів і текстових вузлів це коментар(#comment)
Навіть директива <!DOCTYPE...>, яку ми ставимо на початку HTML, також є DOM-вузлом.
Навіть об'єкт document, який представляє весь документ, формально є DOM-вузлом.

Існує 12 типів вузлів. Але на практиці ми в основному працюємо з 4 з них:

/документ\ – «вхідна точка» в DOM.
/вузли-елементи\ – HTML-теги, основні будівельні блоки.
/текстові вузли\ – містять текст.
/коментарі\ – іноді в них можна включити інформацію, яка не буде показана, але доступна в DOM для читання JS.
---------------------------
Навігація по DOM =>> УРОК 3
---------------------------
Усі операції з DOM починаються з об’єкта document. Це головна “точка входу” в DOM. З нього ми можемо отримати доступ до будь-якого вузла.
--------------------------------------------------------------------
Навігація по вузлам,нащаткам,сусідам
--------------------------------------------------------------------
1.Батьківський вузол доступний як parentNode.

2.Дочірні вузли – елементи, які вкладені у батьківський вузол.

3.Нащадки – всі ЕЛЕМЕНТИ, які вкладені у ВУЗОЛ, включаючи дітей, їхніх дітей.

4.Сусідні вузли – це дочірні вузли їх може бути декілька, які є НАЩАТКАМИ одного батька.

Приклад 1:
<div class="wrapper">
  <h1>Заголовок</h1>
  <ul class="list">
    <li>Перший пункт</li>
    <li>Другий пункт</li>
    <li>Третій пункт</li>
  </ul>
  <p>Підсумок</p>
</div>
Всього вузлів: 5 - <div>, <h1>, <ul>, <li>, <p>.
Дочірні вузли <div class="wrapper">: <h1>, <ul>, <p>.
Сусідні вузли <div class="wrapper">: відсутні, оскільки <div class="wrapper"> єдиний дочірній вузол відповідного рівня ієрархії DOM.
Наслідуючі(нащадки) вузли <div class="wrapper">: <h1>, <ul>, <li> (три елементи), <p>.

childNodes  – спеціальний ітеративний об’єкт-псевдомасив.
(i) - Колекції DOM доступні лише для зчитування
(i) - DOM колекції живі
(i) - не використовуйте for..in для перебору колекцій, for of

--------------------------------------------
Пошук: getElement, querySelector =>> УРОК 4
--------------------------------------------
1.elem.querySelector(css) повертає перший елемент, що відповідає даному CSS-селектору
document.querySelector('#age-table td') document.querySelector('form[name="search"]')
2.document.getElementById(id) - <div id="elem-content">Елемент</div>//містить дефіс(не можна) =>  але так можна window['elem-content']
3.elem.querySelectorAll(css), який повертає всі елементи всередині elem(має статичну колекцію,як фіксований масив,а старі методи пошуки видають живу колекцію)
document.querySelectorAll('#age-table label') клас #age-table > label
4.elem.matches(css) нічого не шукає, він просто перевіряє, чи відповідає elem заданому CSS-селектору. Він повертає true або false.
5.closest шукає предка і повертається знайдений предок.
-----------------------------------------------
Властивості вузлів: тип, тег та вміст =>УРОК 5
-----------------------------------------------
----------------
Класи DOM вузлів
----------------
вузли DOM є звичайними об’єктами JavaScript. Вони використовують прототипні класи для успадкування.
console.dir(document.body) виведе інформацію про властивості та методи об'єкта.//HTMLElement.prototype, Element.prototype і так далі.
Кожен вузол належить відповідному вбудованому класу,всі класи вузлів утворюють єдину ієрархію.
Таким чином, повний набір властивостей та методів для певного вузла формується в результаті ланцюжка успадкування.

Коренем ієрархії є EventTarget, від нього успадковується Node, а інші вузли DOM успадкують вже від нього.

На наведеному нижче рисунку показані основні класи:
(i) - абстрактним класом, це означає, що його призначення - служити базовим класом для інших класів, які можуть реалізувати його методи та властивості, але сам клас не може бути використаний для створення об'єктів.
Замість цього, він використовується для створення інших класів шляхом успадкування.

1."EventTarget" – це кореневий-абстрактний клас для всього,він підтримує “події” на всіх вузлах

2."Node" –  абстрактний-базовий клас для вузлів DOM.Він надає: parentNode, nextSibling, childNodes   

3.класс "Document" - Глобальний об’єкт document належить саме до цього класу. Він служить точкою входу в DOM

4."CharacterData" - абстрактний клас, успадковується: 1.Text(всередині елементів) 2.Comment - скриті від користувача

5."Element" – базовий клас для елементів DOM.Він надає навігаційні можливості на рівні елементів, такі як:nextElementSibling, children та методи пошуку, такі як getElementsByTagName, querySelector.

6."HTMLElement" – це базовий клас для всіх HTML-елементів. Ми будемо працювати з ним більшість часу.
Він успадковується класами конкретних HTML-елементів:HTMLInputElement – клас для елементів <input>

Теги з власними класами, мають властивості та методи,є також,які не мають- <span>, <section>, <article> , вони є екземплярами класу "HTMLElement".!!!


Наприклад, давайте розглянемо об’єкт DOM для елемента <input>.Нижче наведені класи:
Він отримує ВЛАСТИВОСТІ та МЕТОДИ шляхом “накладання” наступних класів (подані в порядку успадкування):
HTMLInputElement – цей клас надає ВЛАСТИВОСТІ для елемента введення,
HTMLElement – надає  МЕТОДИ для HTML-елементів (такі як отримання та встановлення значень),
Element – надає загальні МЕТОДИ для елементів,
Node – надає загальні ВЛАСТИВОСТІ для вузлів DOM,
EventTarget – цей клас забезпечує підтримку подій  і цей клас успадковується від Object, тому він має доступ до загальних МЕТОДІВ “простого об’єкту”, наприклад, hasOwnProperty.

Щоб визначити ім’я класу вузла,можемо скористатись у об’єкта ВЛАСТИВІСТЮ constructor.
alert(document.body.constructor.name); // HTMLBodyElement
alert(document.body); // [object HTMLBodyElement]

instanceof - перевіряє наслідування boolean:
alert(document.body instanceof HTMLBodyElement)
--------------------------------------------
Властивість “nodeType” - визначає тип вузла 
--------------------------------------------
nodeType має числове значення:
elem.nodeType == 1 для вузлів-елементів,console.log(document.body.nodeType)//1
3 для текстових вузлів,9 для об’єкта документа
------------------------
Тег: nodeName та tagName
------------------------
Для визначення імені тегу ми можемо скористатися властивостями nodeName або tagName.

alert( document.body.nodeName ); // BODY
alert( document.body.tagName ); // BODY

tagName-тільки для вузлів(Element),nodeName - про інші типи вузлів.

Для прикладу, порівняємо tagName і nodeName для вузла document та коментаря:

<body><!-- коментар -->

  <script>
    // для коментаря
    alert( document.body.firstChild.tagName ); // undefined (це не елемент)
    alert( document.body.firstChild.nodeName ); // #comment

    // для документу
    alert( document.tagName ); // undefined (це не елемент)
    alert( document.nodeName ); // #document
  </script>
</body>

-----------------
innerHTML: вміст
-----------------
Властивість innerHTML дозволяє отримати HTML всередині елемента як рядок.Ми також можемо змінювати його. 

(i) - Скрипти не виконуються
(i) - “innerHTML+=” повністю перезаписує вміст

Оскільки вміст “обнуляється” і перезаписується з нуля, всі зображення та інші ресурси будуть перезавантажені.
-------------------------------
outerHTML: повний HTML елемента
-------------------------------
Властивість outerHTML містить повний HTML елемента. Це як innerHTML, але включає сам елемент.
    <div id="elem">Привіт <b>Світ</b></div>

    <script>
    alert(elem.outerHTML); // <div id="elem">Привіт <b>Світ</b></div>
    </script>

(i) - відміну від innerHTML, запис у outerHTML не змінює елемент. Замість цього він замінює його в DOM.
----------------------------------`
data: вміст тексту вузла
----------------------------------
Властивість innerHTML існує лише для вузлів-елементів.
Інші типи вузлів, такі як текстові вузли, мають:data властивості. 
<body>
  Привіт
  <!-- Коментар -->
  <script>
    let text = document.body.firstChild;
    alert(text.data); // Привіт

    let comment = text.nextSibling;
    alert(comment.data); // Коментар
  </script>
</body>
--------------------------
textContent: чистий текст
--------------------------
Властивість textContent надає доступ до тексту всередині елемента: лише текст, без усіх <тегів>.

Різниця між innerHTML та textContent:
 -За допомогою innerHTML він буде вставлений “як HTML”, з усіма HTML-тегами.
 -За допомогою textContent він буде вставлений “як текст”, всі символи будуть трактуватися буквально.

<div id="elem1"></div>
 <div id="elem2"></div>

    <script>
    let name = prompt("Як вас звати?", "<b>Вінні Пух!</b>");

    elem1.innerHTML = name;
    elem2.textContent = name;
    </script>
 Перший <div> отримує назву “як HTML”: всі теги стають тегами, тому ми бачимо назву жирним шрифтом.//Вінні Пух!
 Другий <div> отримує назву “як текст”, тому ми буквально бачимо <b>Вінні Пух!</b>.//<b>Вінні Пух!</b>
--------------------
Властивість “hidden”
--------------------
Атрибут “hidden” та властивість визначає видно елемент чи ні.
Технічно, hidden працює так само, як style="display:none". Але це коротше писати.
<div id="elem">Блимаючий елемент</div>
setInterval(() => elem.hidden = !elem.hidden, 1000);
-------------------
Більше властивостей
-------------------
Елементи також мають додаткові властивості, зокрема, ті, які залежать від класу:
value – значення для <input>, <select> та <textarea> (HTMLInputElement, HTMLSelectElement…).
href – адрес посилання “href” для <a href="..."> (HTMLAnchorElement).
id – значення атрибуту “id” для всіх елементів (HTMLElement).
<input type="text" id="elem" value="value">
    <script>
    alert(elem.type); // "text"
    alert(elem.id); // "elem"
    alert(elem.value); // значення
    </script>

--------------------------------
Атрибути та властивості УРОК =>6
--------------------------------
Коли браузер завантажує сторінку,він “парсить” HTML і генерує DOM об’єкти з нього. Для вузлів-елементів більшість стандартних атрибутів HTML автоматично стають властивостями об’єктів DOM.

Наприклад,тег <body id="page"> => body.id="page". 

Але представлення атрибутів через властивості не відбувається один до одного! У цій главі ми звернемо увагу на відмінності цих двох концепцій, щоб навчитись, як з ними працювати, коли вони співпадають і коли відрізняються.
---------------
DOM властивості
---------------
Властивості - id,type,class в DOM.
Існують багато вбудованих властивостей DOM. Їх багато. Але технічно ніхто нас не обмежує, і якщо їх недостатньо, ми можемо додати власні.

(Приклад 1), створімо нову властивість у document.body:
document.body.myData = {
    name: 'Цезар',
    title: 'Імператор'
 };
 alert(document.body.myData.title); // Імператор

Ми також можемо додати метод (Приклад 2):
document.body.sayTagName = function() {
  alert(this.tagName);
 };
 document.body.sayTagName(); // BODY (значення "this" у методі є document.body)

Ми також можемо додати метод(Приклад 3):
document.body.sayTagName = function() {
  alert(this.tagName);//BODY
 };
 document.body.sayTagName(); // BODY (значення "this" у методі є document.body)

Ми також можемо змінювати вбудовані прототипи, такі як Element.prototype і додати нові методи для всіх елементів (Приклад 4):
Element.prototype.sayHi = function () {
        alert(`hello i'm ${this.tagName}`)
     }
     document.documentElement.sayHi()
     document.body.sayHi()

Отже, властивості та методи DOM поводяться так само, як і звичайні об’єкти JavaScript
---------------
HTML атрибути
---------------
У HTML, теги можуть мати атрибути. Коли браузер аналізує HTML і створює DOM-об’єкти для тегів, він розпізнає стандартні атрибути та створює з них властивості DOM.

Всі атрибути доступні за допомогою наступних методів:

elem.hasAttribute(name) – перевіряє наявність атрибута.// input.setAttribute('Test',123)
elem.getAttribute(name) – отримує значення атрибута. //value.getAttribute('about') console.log(input.outerHTML)
elem.setAttribute(name, value) – встановлює значення атрибута. //el.setAttribute('Test',123)
elem.removeAttribute(name) – видаляє атрибут.
elem.attributes - це колекція об’єктів, які належать вбудованому класу Attr, і мають властивості name та value.
<input id="input" about="elephant" type="text">
//  for (let el of input.attributes) {
              console.log(`${el.name} = ${el.value}`)
         }

(i) - Їхні значення завжди є рядками.
(i) - Нечутливі до регістру. 
---------------------------------------
Синхронізація властивостей і атрибутів
---------------------------------------
Коли стандартний атрибут змінюється, відповідна властивість автоматично оновлюється і, за деякими винятками, ні.

У наведеному нижче прикладі id модифікується як атрибут, і ми також можемо побачити, що властивість теж змінюється. А потім те ж саме навпаки:
<input>
<script>
  let input = document.querySelector('input');

  // атрибут => властивість
  input.setAttribute('id', 'id');
  alert(input.id); // id (оновлений)

  // властивість => атрибут
  input.id = 'newId';
  alert(input.getAttribute('id')); // newId (оновлений)
</script>

Але є винятки, наприклад, input.value синхронізується лише в одному напрямку, з атрибуту → до властивості, але не навпаки(Приклад 2):
<input>
<script>
  let input = document.querySelector('input');

  // атрибут => властивість
  input.setAttribute('value', 'text');
  alert(input.value); // text

  // НІ властивість => атрибут
  input.value = 'newValue';
  alert(input.getAttribute('value')); // text (не оновлено!)
</script>
У прикладі 2:
- Зміна атрибута value оновлює властивість.
- Але зміна властивості не впливає на атрибут.
--------------------------
Властивості DOM типізовані
--------------------------
Властивості DOM не завжди є рядками. Наприклад, властивість input.checked (для чекбоксів) має (boolean) тип даних:
Приклад 1 з буліновим значенням:
 <input id="input" type="checkbox" checked> чекбокс
 <script>
   alert(input.getAttribute('checked')); // значення атрибута: ПОРОЖНІЙ РЯДОК
   alert(input.checked); // значення властивостей є: true
 </script>

Приклад 2 з властивістю об'єкта
Атрибут style – це рядок, але властивість style є об’єктом:
    <div id="div" style="color:red;font-size:120%">Привіт</div>
    <script>
    // рядок
    alert(div.getAttribute('style')); // color:red;font-size:120%
    // об’єкт
    alert(div.style); // [object CSSStyleDeclaration]
    alert(div.style.color); // red
    </script>
------------------------------------------
Нестандартні атрибути,властивість dataset
------------------------------------------
Нестандартні атрибути використовуються:1. для передачі користувацьких даних з HTML до JavaScript 2.для “позначення” HTML-елементів для JavaScript.

Всі атрибути, які починаються з “data” зарезервовані для використання програмістами. Вони доступні у властивості dataset.

Наприклад, якщо elem має атрибут, що називається "data-about", то він доступний як elem.dataset.about.
Атрибути – це те, що написано в HTML.
Властивості – це те, що є в об’єктах DOM.
----------------------------------
Внесення змін в документ => урок 7
----------------------------------

Створення повідомлення
// 1. Створюємо елемент <div>
    let div = document.createElement('div');

    // 2. Задаємо йому клас "alert"
    div.className = "alert";

    // 3. Наповнюємо його змістом
    div.innerHTML = "<strong>Всім привіт!</strong> Ви прочитали важливе повідомлення.";
    //4.document.body.append(div);


"beforebegin" – вставити html безпосередньо перед elem,
"afterbegin" – вставити html в elem, на початку,
"afterend" – вставити html безпосередньо після elem.
"beforeend" – вставити html в elem, в кінці,

1.insertAdjacentHTML('beforebegin', '<p>Привіт</p>');
2.insertAdjacentText(куди, текст)
3.elem.insertAdjacentElement(куди, текст)

----------------------------
Клонування вузлів: cloneNode
----------------------------
Можна створити функцію та помістити код в неї. Але є ще один спосіб – клонувати наявний div та змінити текст всередині (якщо потрібно).

Виклик elem.cloneNode(true) створює копію елемента – з усіма атрибутами та піделементами. Якщо ми викличемо elem.cloneNode(false), тоді буде створена копія без дочірніх елементів.
Ex
<div class="alert" id="div">
  <strong>Всім привіт!</strong> Ви прочитали важливе повідомлення.
    </div>

    <script>
    let div2 = div.cloneNode(true); // клонувати елемент
    div2.querySelector('strong').innerHTML = 'Bye there!'; // змінити клона

    div.after(div2); // вставити клонований елемент після існуючого `div`
    </script>
Recap

Методи для створення нових вузлів:
document.createElement(tag) – створює елемент з заданим тегом,
elem.cloneNode(deep) – клонує елемент, якщо deep==true, то з усіма нащадками.

Вставка та видалення:

node.append(...nodes or strings) – вставляє в node, в кінець,
node.prepend(...nodes or strings) – вставляє в node, на початку,
node.before(...nodes or strings) – вставляє прямо перед node,
node.after(...nodes or strings) – вставляє відразу після node,
node.replaceWith(...nodes or strings) – замінює node.
node.remove() – видаляє node.

Метод elem.insertAdjacentHTML(where, html) вставляє заданий HTML в залежності від значення параметра where:

"beforebegin" – вставляє html прямо перед elem,
"afterbegin" – вставляє html в elem, на початку,
"beforeend" – вставляє html в elem, в кінці,
"afterend" – вставляє html відразу після elem.
